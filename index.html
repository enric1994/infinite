<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="3D resume of Enric Moreu">
    <meta name="keywords" content="3D, resume, Enric Moreu">
    <meta name="author" content="Enric Moreu">
    <meta name="theme-color" content="black">
    <meta property='og:title' content='Enric Moreu | 3D resume' />
    <!-- <meta property='og:image' content='https://github.com/enric1994/resume/raw/master/preview.png' /> -->
    <meta property='og:description' content='3D resume of Enric Moreu' />
    <meta property='og:url' content='https://resume.enricmor.eu' />
    <link rel="shortcut icon" href="favicon.png">
    <title>Enric Moreu | 3D resume</title>
    <style>
        html {
            overflow: hidden;
            overscroll-behavior: none;
        }

        body {
            margin: 0;
            background: linear-gradient(to bottom, #0b9ed9, #07c7f2);
        }

        canvas {
            display: block;
        }
    </style>
    <!-- <script>history.scrollRestoration = "manual"</script> -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.143.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.143.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats-js@1.0.1/build/stats.min.js"></script>
</head>

<body>
    <script>
        const INERTIA_FACTOR = 0.005
        const INERTIA_DECAY = 0.97;
        const KEY_SPEED = 6;
        const FOV = 45;
        const MAX_SCALE = 10000;
        const MIN_SCALE = 0.0001;
        const LOCK_SALE = 1;
        const model_names = ['title.glb', 'city.glb', 'languages.glb', 'uni.glb', 'title.glb'];

        function camera_path() {
            camera.position.x = 15 * Math.sin(0.2 * Math.log2(models[0].scale.x));
            camera.position.y = 1 + 1 * Math.sin(0.3 * Math.log2(models[0].scale.x));
            camera.position.z = -5 + 15 * Math.cos(0.1 * Math.log2(models[0].scale.x));
            camera.lookAt(0, 0, 0);
        }

        function scale_models(scrollIntensity) {
            for (let i = 0; i < models.length; i++) {
                current_scale = models[i].scale.x;
                new_scale = current_scale + scrollIntensity * current_scale;
                models[i].scale.set(new_scale, new_scale, new_scale);
                if (models[i].scale.x > MAX_SCALE || models[i].scale.x < MIN_SCALE) {
                    models[i].visible = false;
                } else {
                    models[i].visible = true;
                }
            }
        }

        // Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(FOV, window.innerWidth / window.innerHeight, 1, 100000000);
        const clock = new THREE.Clock();
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, logarithmicDepthBuffer: true });
        const loader = new THREE.GLTFLoader();

        renderer.setPixelRatio(2);
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        renderer.powerPreference = "high-performance";
        renderer.shadowMap.enabled = true
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.physicallyCorrectLights = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Stats
        const stats = new Stats()
        stats.showPanel(0) // 0: fps, 1: ms, 2: mb, 3+: custom
        document.body.appendChild(stats.dom)

        // Lighting
        const ambientLight = new THREE.AmbientLight('white', .75);
        scene.add(ambientLight)

        const hemiLight = new THREE.HemisphereLight('white', 'orange', 1);
        scene.add(hemiLight)

        // Directional light 1
        const dir1 = new THREE.DirectionalLight('white', 1);
        dir1.position.set(10, 10, 10);
        scene.add(dir1)

        // Directional light 2 
        const dir2 = new THREE.DirectionalLight('white', 1);
        dir2.position.set(-10, 10, 10);
        scene.add(dir2)

        // Directional light 3
        const dir3 = new THREE.DirectionalLight('white', 1);
        dir3.position.set(-10, 10, -10);
        scene.add(dir3)

        // Directional light 4
        const dir4 = new THREE.DirectionalLight('white', 1);
        dir4.position.set(10, 10, -10);
        scene.add(dir4)

        // Directional light 5
        const dir5 = new THREE.DirectionalLight('white', 0.7);
        dir2.position.set(-10, 10, -5);
        scene.add(dir5)

        const shadowLight = new THREE.DirectionalLight(0xffffff, 1.0);
        shadowLight.position.set(0.1, 1.5, 0.1);
        shadowLight.castShadow = true;
        scene.add(shadowLight);
        shadowLight.shadow.mapSize.width = 5000;
        shadowLight.shadow.mapSize.height = 5000;

        shadowLight.shadow.camera.near = 1;
        shadowLight.shadow.camera.far = 50;
        shadowLight.shadow.camera.top = 50;
        shadowLight.shadow.camera.bottom = -50;
        shadowLight.shadow.camera.left = -50;
        shadowLight.shadow.camera.right = 50;
        shadowLight.shadow.camera.updateProjectionMatrix();
        shadowLight.castShadow = true;
        shadowLight.shadow.bias = -0.001;

        // Load models
        let models = [];


        function loadModel(modelName, scale_ratio) {
            return new Promise((resolve, reject) => {
                loader.load(modelName, function (gltf) {
                    const model = gltf.scene;
                    const scale = model.scale.x;
                    model.scale.set(scale / scale_ratio, scale / scale_ratio, scale / scale_ratio);

                    // Cast shadows to objects
                    model.castShadow = true;
                    model.traverse(function (node) {
                        if (node instanceof THREE.Mesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            node.flatShading = true;
                            node.blending = THREE.NoBlending;
                            const newMaterial = new THREE.MeshPhongMaterial({ color: node.material.color });
                            node.material = newMaterial;

                        }
                    });
                    scene.add(model);

                    // Enable animations
                    if (gltf.animations && gltf.animations.length) {
                        const mixer = new THREE.AnimationMixer(model);
                        gltf.animations.forEach((clip) => {
                            mixer.clipAction(clip).play();
                        });
                        model.mixer = mixer;
                    }
                    resolve(model);
                }, undefined, reject);
            });
        }
        async function loadModels() {
            models.push(await loadModel('models/' + model_names[0], 1));
            camera_path()
            for (let i = 1; i < model_names.length; i++) {
                models.push(await loadModel('models/' + model_names[i], 100 ** (i)));
                console.log('Load model', model_names[i])
                // await new Promise(r => setTimeout(r, 500));
            }
        }
        loadModels()

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        // Handle scroll to rescale models
        window.addEventListener('wheel', (event) => {
            const scrollIntensity = event.deltaY * INERTIA_FACTOR;

            if (
                (models.at(0).scale.x + scrollIntensity * models.at(0).scale.x > LOCK_SALE && scrollIntensity < 0) ||
                (models.at(-1).scale.x - scrollIntensity * models.at(0).scale.x < LOCK_SALE && scrollIntensity > 0)
            ) {
                scale_models(scrollIntensity)
                camera_path()
            }
        });

        // Handle touch events to rescale models
        let touchStartX = 0;
        let touchStartY = 0;
        let inertia = 0;

        window.addEventListener('touchstart', (event) => {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
            inertia = 0;
        });

        window.addEventListener('touchmove', (event) => {
            const touchX = event.touches[0].clientX;
            const touchY = event.touches[0].clientY;
            const deltaX = touchX - touchStartX;
            const deltaY = touchY - touchStartY;
            const scrollIntensity = -deltaY * INERTIA_FACTOR;

            if (
                (models.at(0).scale.x > LOCK_SALE && scrollIntensity < 0) ||
                (models.at(-1).scale.x < LOCK_SALE && scrollIntensity > 0)
            ) {
                scale_models(scrollIntensity)
                camera_path()

                inertia = deltaY;
                touchStartX = touchX;
                touchStartY = touchY;
            }

        });

        window.addEventListener('touchend', () => {
            function inertiaLoop() {
                if (Math.abs(inertia) > 0.01) {
                    const scrollIntensity = -inertia * INERTIA_FACTOR;

                    if (
                        (models.at(0).scale.x > LOCK_SALE && scrollIntensity < 0) ||
                        (models.at(-1).scale.x < LOCK_SALE && scrollIntensity > 0)
                    ) {
                        scale_models(scrollIntensity)
                        camera_path()

                        inertia *= INERTIA_DECAY;
                        requestAnimationFrame(inertiaLoop);
                    }
                }
            }
            inertiaLoop();
        });

        let keyInertia = 0;
        let keyInterval;

        function handleKeyInertia() {
            if (Math.abs(keyInertia) > 0.01) {
                const scrollIntensity = keyInertia * INERTIA_FACTOR;

                if (
                    (models.at(0).scale.x > LOCK_SALE && scrollIntensity < 0) ||
                    (models.at(-1).scale.x < LOCK_SALE && scrollIntensity > 0)
                ) {
                    scale_models(scrollIntensity);
                    camera_path();
                    keyInertia *= INERTIA_DECAY;
                } else {
                    clearInterval(keyInterval);
                }
            } else {
                clearInterval(keyInterval);
            }
        }

        window.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                clearInterval(keyInterval);
                keyInertia = (event.key === 'ArrowUp' ? -KEY_SPEED : KEY_SPEED);
                keyInterval = setInterval(handleKeyInertia, 10);
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                keyInertia *= INERTIA_DECAY;
            }
        });


        // Animation loop 
        function animate() {
            stats.begin();

            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            for (let model of models) {
                if (model.mixer) {
                    model.mixer.update(delta);
                }
            }
            renderer.render(scene, camera);

            stats.end();
        }
        animate();
    </script>
</body>

</html>